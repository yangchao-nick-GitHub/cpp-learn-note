# C++基础学习

## 基础

---

**const 用法**

- const限定的变量必须初始化
- const和指针结合，“左物右指”
- 不允许非const指针赋值给const指针
- const修饰函数参数
- const 可以修饰类函数 类变量
- 在C++中const变量在其他文件不可见，类似与static修饰
- 用作函数参数， 防止修改，起保护作用，增加程序健壮性
- 其他文件需要引用const变量，两文件都要加 extern 修饰

```cpp
// file1.cpp
extern const int ext = 10;
//file2.cpp
extern int ext;
```

- **（const在读内存方面C/C++有区别）**读取const变量值，对于C语言需要从变量内存读取，对于C++语言const变量在编译期间就被替换了,下面代码C语言中是20，C++中还是10，因为C++中编译时已经把const 变量给替换了

```cpp
const int a = 10;
int *p = (int*)&a;
*p = 20;
printf("%d\n",a);
```

**static 用法**

- static类成员变量类对象共享静态内存
- static类生命周期在作用域范围内
- static成员函数只能访问静态成员和静态函数

## 类和对象

---

- 一旦在类中定义了构造函数，那么创建对象时就一定要调用
- 成员变量的初始化顺序与初始化列表中列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关
- 包含成员对象的类叫封闭类，封闭类对象生成时，先执行所有成员对象的构造函数，然后才执行封闭类自己的构造函数，封闭类对象消亡时，先执行封闭类的析构函数，然后再执行成员对象的析构函数
- this 虽然用在类的内部，但是只有在对象被创建以后才会给 this 赋值
- static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配，所以static 成员变量必须在类声明的外部初始化， 初始化方式：int A::m_a = 10; static成员变量不属于任何对象，static 成员变量在全局区分配内存，程序终止才销毁
- 普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员
- const对象只能调用类的const成员
- 友元函数必须要传入对象地址，友元函数不同于类的成员函数，在友元函数中不能直接访问类的成员，必须要借助对象，类也可以引用其他类接口做友员函数
- C++ class和struct有区别

## C++引用

---

- 获取引用的地址实际是被引用变量的地址，引用实际是一个指针的封装指向这个被引用变量，但是实际引用的地址并不可见
- C++引用不能绑定到临时数据，临时数据，例如表达式的结果、函数的返回值等，它们可能会放在内存中，也可能会放在寄存器中，不可引用临时数据，对象、结构体变量是自定义类型的数据一般会放入内存

## 类的继承

---

- 如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样
- 派生类的内存模型可以看成是基类成员变量和新增成员变量的总和
- 派生类的构造函数中，父类要在派生类构造初始化列表中调用，先调用直接父类的构造函数再执行派生类构造函数体
- 销毁派生类对象时，先执行派生类析构函数，再执行基类析构函数
- 为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员
- 虚继承的子类构造函数先要调用间接虚基类，再调用父类，如
    
    ```cpp
    D::D(int a, int b, int c, int d): B(90, b), C(100, c), A(a), m_d(d){ }
    ```
    
- 虚继承下的内存模型：对于普通继承，基类子对象始终位于派生类对象的前面，对于虚继承，恰恰和普通继承相反，大部分编译器会把基类成员变量放在派生类成员变量的后面，某个派生类有一个或多个虚基类，编译器就会在派生类对象中安插一个指针，指向虚基类表。虚基类表其实就是一个数组，数组中的元素存放的是各个虚基类的偏移
    - 假设 A 是 B 的虚基类，同时 B 又是 C 的虚基类，那么各对象的内存模型如下图所示：
    
    ![Untitled](C++%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%20bc93268de2e845dc95dd27f6de45bf69/Untitled.png)
    
    - 假设 A、B、C、D 类的继承关系为：
    
    ![Untitled](C++%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%20bc93268de2e845dc95dd27f6de45bf69/Untitled%201.png)
    
    那么 obj_d 的内存模型如下图所示：
    
    ![Untitled](C++%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%20bc93268de2e845dc95dd27f6de45bf69/Untitled%202.png)
    
- 子类对象赋值给父类对象，是拷贝子对象的成员变量到父类对象
- 子类对象指针赋值给父类对象指针，父类指针访问的就是子类成员变量，但是父类指针访问成员函数却是访问的自己的成员函数，编译器通过指针来访问成员变量，指针指向哪个对象就使用哪个对象的数据；编译器通过指针的类型来访问成员函数，指针属于哪个类的类型就使用哪个类的函数， （引用赋值效果和指针效果相同）

## C++多态和虚函数

---

- 父子类成员函数构成名字遮蔽（除了函数体其余都相同）且父类成员函数是virtual函数，父类指针指向子类对象时，调用子类对象成员函数，构成多态
- 大部分情况下都应该将基类的析构函数声明为虚函数，防止指针释放没有调用子类析构函数
- 包含纯虚函数的类称为抽象类，无法创建对象，派生的派生类必须实现纯虚函数才能被实例化
- C++虚函数表内存布局
    
    ```cpp
    class A {
    public:
        virtual void vfunc1();
        virtual void vfunc2();
        void func1();
        void func2();
    private:
        int m_data1, m_data2;
    };
    
    class B : public A {
    public:
        virtual void vfunc1();
        void func1();
    private:
        int m_data3;
    };
    
    class C: public B {
    public:
        virtual void vfunc2();
        void func2();
    private:
        int m_data1, m_data4;
    };
    ```
    
    虚函数指针布局如下：
    
    ![Untitled](C++%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%20bc93268de2e845dc95dd27f6de45bf69/Untitled%203.png)
    

## C++运算符重载

---

- 有一部分运算符重载既可以是成员函数也可以是全局函数，虽然没有一个必然的、不可抗拒的理由选择成员函数，但我们应该优先考虑成员函数，这样更符合运算符重载的初衷；另外有一部分运算符重载必须是全局函数，这样能保证参数的对称性，通常全局函数的形式重载+  以成员函数的形式重载+=，全局函数不会发生构造转换的情况，构造转换容易发生二义性错误，通常的运算符重载以成员函数提供
- C++重载>>和<<时通常使用全局函数重载，因为需要istream和ostream标准类访问我们类的私有成员函数实现
- [C++](https://c.biancheng.net/cplus/) 规定，下标运算符`[ ]`必须以成员函数的形式进行重载，通常需要实现带const和不带const的重载

```cpp
返回值类型 & operator[ ] (参数);
const 返回值类型 & operator[ ] (参数) const;
```

- 自增`++`和自减`--`都是一元运算符，它的前置形式和后置形式都可以被重载

```cpp
类名 operator++();  //++i，前置形式
类名 operator++(int);  /
```

## C++模板

---

- 函数模板解决不同的类型使用同一种算法的问题，模板化的函数也可以重载

```cpp
template<class T> void Swap(T &a, T &b);
template<typename T> void Swap(T a[], T b[], int len);
```

- 对于函数模板，类型转换则受到了更多的限制，仅能进行「const 转换」和「数组或函数指针转换,最好在具体指定模板参数，不要依赖编译器通过参数去推导
- 函数模板的显式具体化：对于模板函数，对于不同模板参数类型使用不同的算法，可以理解为：如果传入指定的类型，就去执行指定函数，类模板显式具体化也是一样。还有部分显示具体化，部分显式具体化只能用于类模板，不能用于函数模板

```cpp
template<class T> const T& Max(const T& a, const T& b);
template<> const STU& Max<STU>(const STU& a, const STU& b);//函数模板的显示具体化（针对STU类型的显示具体化）
// 原来使用 T 的位置都应该使用 STU 替换

//类模板的部分显示具体化
template<typename T2> class Point<char*, T2>{
```

- 类模板创建对象时并不会实例化所有的成员函数，只有等到真正调用它们时才会被实例化,类模板创建对象时，一般只需要实例化成员变量和构造函数,这一点非常重要，有一个常见的规则：**将类模板或者函数模板的声明和定义都放在头文件，让使用该模板函数或者模板类的cpp文件去include该头文件，只要在一个文件中出现函数模板类模板的调用行为，模板类或函数才会生成（推荐使用模板实现也放在头文件）**
- 函数体显示实例化模板函数和类：直接在模板处定义模板的类型，这样模板的声明和定义就可以在头文件中和cpp文件中了，如下

```cpp
// func.cpp

template<typename T> void Swap(T &a, T &b){
    T temp = a;
    a = b;
    b = temp;
}

template void Swap(double &a, double &b);  //显式实例化定义 没有<>符号
```

类模板也可以显示实例化，另外需要注意的是，显式实例化一个类模板时，会一次性实例化该类的所有成员，包括成员变量和成员函数（显示实例化不推荐使用，会造成不易维护的问题）

## C++异常

---

- 发生异常时必须将异常明确地抛出，try 才能检测到；如果不抛出来，即使有异常 try 也检测不到

我们可以将 catch 看做一个没有返回值的函数，当异常发生后 catch 会被调用，并且会接收实参（异常数据）。但是这个catch是在运行是接收异常类型，没法在编译期间检查

## C++面向对象进阶

---

- 构造函数的本意是在创建对象的时候初始化对象，编译器会根据传递的实参来匹配不同的来调用不同的构造函数，构造函数分为多种

```cpp
// 默认构造函数
Complex();  //没有参数

// 用户自定义的构造函数
Complex(double real, double imag);  //两个参数

// 拷贝构造函数, 以拷贝的方式初始化对象
Complex(const Complex &c);

// 转换构造函数。将其它类型转换为当前类类型时调用
Complex(double real);

// e.g.
Complex c1();  //调用Complex()
Complex c2(10, 20);  //调用Complex(double real, double imag)
Complex c3(c2);  //调用Complex(const Complex &c)
Complex c4(25.7);  //调用Complex(double real)
```

对象内存在首次用数据填充时才调用构造函数，这时传入的参数类型不同调用不同的构造函数，这里提下转换构造函数，将其它类型转换为当前类类型时会调用转换构造函数，转换构造函数只有一个参数

- C++提供类型转换函数，将当前类类型转换为其它类型，它只能以成员函数的形式出现,不允许转换为数组或函数类型，转换为指针类型或引用类型是可以的

```cpp
operator double() const { return m_real; }  //类型转换函数
```

转换构造函数和类型转换函数的作用是相反的，不可同时存在，否则会产生二义性

- C++增加了四种强制类型转换的语法
    - static_cast：用于原有类型的转换和指针类型之间的转换，如short 转 int，void *转int *
    - const_cast：用于 const 与非 const之间的转换
    - reinterpret_cast：高度危险的转换，这种转换仅仅是对二进制位的重新解释
    - dynamic_cast：用于类型安全的向下转型